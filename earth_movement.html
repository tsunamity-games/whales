<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ocean Sailing Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #e6f7ff;
        }
        canvas {
            border: 2px solid #7ec0ee;
            cursor: pointer;
        }
        .info {
            text-align: center;
            margin-top: 10px;
        }
        .title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .latitude-line, .longitude-line {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }
        .latitude-line {
            width: 100%;
            height: 1px;
        }
        .longitude-line {
            height: 100%;
            width: 1px;
        }
    </style>
</head>
<body>
    <h1 class="title">Ocean Sailing Game</h1>
    <canvas id="oceanCanvas" width="512" height="512"></canvas>
    <div class="info">
        <p id="currentLocation">Current Location: Latitude: 0.00°, Longitude: 0.00°</p>
        <p id="currentPixel">Current Pixel Position: X: 256, Y: 256</p>
        <p id="cursorPosition">Cursor Position: Latitude: 0.00°, Longitude: 0.00° | X: 0, Y: 0</p>
        <p id="sailingInfo"></p>
    </div>

    <script>
        const canvas = document.getElementById('oceanCanvas');
        const ctx = canvas.getContext('2d');
        let shipPosition = { x: 256, y: 256 };
        let currentLocation = { lat: 0, lon: 0 };
        let targetLocation = null;
        let isMoving = false;

        const continents = {
            northAmerica: [
                { x: 50, y: 180 },
                { x: 100, y: 150 },
                { x: 130, y: 100 },
                { x: 160, y: 130 },
                { x: 180, y: 220 },
                { x: 140, y: 250 },
                { x: 50, y: 180 }
            ],
            otherContinent: [
                { x: 250, y: 150 },
                { x: 300, y: 130 },
                { x: 320, y: 180 },
                { x: 280, y: 220 },
                { x: 250, y: 180 }
            ]
        };

        // Utility functions for spherical calculations
        const degToRad = (deg) => deg * (Math.PI / 180);
        const radToDeg = (rad) => rad * (180 / Math.PI);

        // Haversine formula to calculate distance between two points on a sphere
        const haversineDistance = (lat1, lon1, lat2, lon2) => {
            const R = 1; // Normalized radius
            const φ1 = degToRad(lat1);
            const φ2 = degToRad(lat2);
            const Δφ = degToRad(lat2 - lat1);
            const Δλ = degToRad(lon2 - lon1);

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            return R * c;
        };

        // Great circle interpolation
        const interpolateGreatCircle = (start, end, t) => {
            const φ1 = degToRad(start.lat);
            const λ1 = degToRad(start.lon);
            const φ2 = degToRad(end.lat);
            const λ2 = degToRad(end.lon);

            const Δφ = φ2 - φ1;
            const Δλ = λ2 - λ1;

            const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
                      Math.cos(φ1) * Math.cos(φ2) *
                      Math.sin(Δλ/2) * Math.sin(Δλ/2);
            const σ = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

            if (σ === 0) return start;

            const A = Math.sin((1-t)*σ) / Math.sin(σ);
            const B = Math.sin(t*σ) / Math.sin(σ);

            const x = A * Math.cos(φ1) * Math.cos(λ1) + B * Math.cos(φ2) * Math.cos(λ2);
            const y = A * Math.cos(φ1) * Math.sin(λ1) + B * Math.cos(φ2) * Math.sin(λ2);
            const z = A * Math.sin(φ1) + B * Math.sin(φ2);

            const φ = Math.atan2(z, Math.sqrt(x*x + y*y));
            const λ = Math.atan2(y, x);

            return {
                lat: radToDeg(φ),
                lon: radToDeg(λ)
            };
        };

        // Mercator projection conversion functions
        const convertLatLonToMercator = (lat, lon) => {
            const R = 512; // Radius of the projection
            const x = R * (lon + 180) / 360;
            const y = (1 - Math.log(Math.tan(Math.PI / 4 + (lat * Math.PI / 360))) / Math.PI) * (R / 2);
            return { x, y };
        };

        const convertMercatorToLatLon = (x, y) => {
            const R = 512; // Radius of the projection
            const lon = (x * 360 / R) - 180;
            const lat = radToDeg(2 * Math.atan(Math.exp((1 - 2 *y / R) * Math.PI)) - Math.PI / 2);

            // const lon = (x / W) * 360 - 180;
            // const lat = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y / R)))) * (180 / Math.PI);
            
            return { lat, lon };
        };

        const isPointInPolygon = (point, polygon) => {
            let { x, y } = point;
            let inside = false;

            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;

                const intersect = ((yi > y) !== (yj > y)) &&
                                (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }

            return inside;
        };

        const drawMap = () => {
            ctx.fillStyle = '#4A90E2';
            ctx.fillRect(0, 0, 512, 512);

            ctx.fillStyle = '#8B4513';

            // Loop through each continent and draw its shape
            for (const continent of Object.values(continents)) {
                ctx.beginPath();
                ctx.moveTo(continent[0].x, continent[0].y);
                for (let i = 1; i < continent.length; i++) {
                    ctx.lineTo(continent[i].x, continent[i].y);
                }
                ctx.fill();
            }
        };

        // Draw latitude and longitude lines
        const drawLatLonLines = () => {
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 1;

            // Draw latitude lines
            for (let lat = -90; lat <= 90; lat += 30) {
                const mercatorY = convertLatLonToMercator(lat, 0).y;
                ctx.beginPath();
                ctx.moveTo(0, mercatorY);
                ctx.lineTo(512, mercatorY);
                ctx.stroke();
            }

            // Draw longitude lines
            for (let lon = -180; lon <= 180; lon += 30) {
                const mercatorX = convertLatLonToMercator(0, lon).x;
                ctx.beginPath();
                ctx.moveTo(mercatorX, 0);
                ctx.lineTo(mercatorX, 512);
                ctx.stroke();
            }
        };

        // Initial map drawing
        drawMap();
        drawLatLonLines();

        // Draw ship function
        const drawShip = (x, y) => {
            ctx.save();
            ctx.translate(x, y);
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.moveTo(0, -10);
            ctx.lineTo(-5, 10);
            ctx.lineTo(5, 10);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        };

        currentLocation = convertMercatorToLatLon(shipPosition.x, shipPosition.y);
        drawShip(shipPosition.x, shipPosition.y);

        // Update current pixel and spherical position
        const updatePositionDisplay = () => {
            document.getElementById('currentLocation').innerText = `Current Location: Latitude: ${currentLocation.lat.toFixed(2)}°, Longitude: ${currentLocation.lon.toFixed(2)}°`;
            document.getElementById('currentPixel').innerText = `Current Pixel Position: X: ${shipPosition.x.toFixed(2)}, Y: ${shipPosition.y.toFixed(2)}`;
        };

        updatePositionDisplay();

        // Movement animation
        const animateMovement = (startLocation, endLocation, duration) => {
            const startTime = performance.now();

            const animate = (currentTime) => {
                const elapsedTime = currentTime - startTime;
                const progress = Math.min(elapsedTime / duration, 1);

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawMap();
                drawLatLonLines();

                const interpolatedLocation = interpolateGreatCircle(startLocation, endLocation, progress);
                const mercatorPos = convertLatLonToMercator(interpolatedLocation.lat, interpolatedLocation.lon);

                drawShip(mercatorPos.x, mercatorPos.y);

                currentLocation = interpolatedLocation;
                shipPosition = mercatorPos;
                updatePositionDisplay();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    isMoving = false;
                    targetLocation = null;
                    document.getElementById('sailingInfo').innerText = '';
                }
            };

            requestAnimationFrame(animate);
        };

        // Canvas click event listener
        canvas.addEventListener('click', (event) => {
            if (isMoving) return;

            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Convert clicked position to lat/lon
            const location = convertMercatorToLatLon(x, y);
            targetLocation = location;

            document.getElementById('sailingInfo').innerText = `Sailing to: Latitude: ${targetLocation.lat.toFixed(2)}°, Longitude: ${targetLocation.lon.toFixed(2)}°`;

            const startLocation = currentLocation;
            const totalDistance = haversineDistance(startLocation.lat, startLocation.lon, targetLocation.lat, targetLocation.lon);
            const duration = totalDistance * 2000; // 2 seconds per unit distance

            isMoving = true;
            animateMovement(startLocation, targetLocation, duration);
        });

        // Mouse move event listener to update cursor position in real-time
        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const cursorLocation = convertMercatorToLatLon(x, y);
            document.getElementById('cursorPosition').innerText = `Cursor Position: Latitude: ${cursorLocation.lat.toFixed(2)}°, Longitude: ${cursorLocation.lon.toFixed(2)}° | X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}`;
        });
    </script>
</body>
</html>